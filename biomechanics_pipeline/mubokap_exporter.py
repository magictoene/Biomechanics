"""
MuboKap Exporter Module

Generates MuboKap Input files in MATLAB-compatible .txt format.
"""

import numpy as np
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime


class MuboKapExporter:
    """
    Exporter for creating MuboKap Input files from analyzed biomechanical data.
    """
    
    def __init__(self):
        self.data_sections = {}
        self.metadata = {}
        
    def set_metadata(self, **kwargs) -> None:
        """
        Set metadata for the MuboKap file.
        
        Args:
            **kwargs: Metadata key-value pairs
        """
        self.metadata.update(kwargs)
        
        # Add timestamp if not provided
        if 'timestamp' not in self.metadata:
            self.metadata['timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    def add_marker_data(self, marker_data: Dict[str, np.ndarray], section_name: str = 'MARKERS') -> None:
        """
        Add marker coordinate data to the export.
        
        Args:
            marker_data: Dictionary mapping marker names to coordinate arrays
            section_name: Name of the data section
        """
        self.data_sections[section_name] = {
            'type': 'marker_coordinates',
            'data': marker_data
        }
    
    def add_segment_data(self, segment_data: Dict[str, float], section_name: str = 'SEGMENTS') -> None:
        """
        Add segment length data to the export.
        
        Args:
            segment_data: Dictionary mapping segment names to average lengths
            section_name: Name of the data section
        """
        self.data_sections[section_name] = {
            'type': 'segment_lengths',
            'data': segment_data
        }
    
    def add_statistics(self, stats_data: Dict[str, Dict[str, float]], section_name: str = 'STATISTICS') -> None:
        """
        Add statistical data to the export.
        
        Args:
            stats_data: Dictionary with statistics for each item
            section_name: Name of the data section
        """
        self.data_sections[section_name] = {
            'type': 'statistics',
            'data': stats_data
        }
    
    def _format_header(self) -> List[str]:
        """
        Format the file header with metadata.
        
        Returns:
            List of header lines
        """
        lines = [
            "% MuboKap Input File",
            "% Generated by Biomechanics Pipeline",
            f"% Created: {self.metadata.get('timestamp', 'Unknown')}",
            "%"
        ]
        
        # Add custom metadata
        for key, value in self.metadata.items():
            if key != 'timestamp':
                lines.append(f"% {key}: {value}")
        
        lines.append("%")
        return lines
    
    def _format_marker_section(self, section_name: str, marker_data: Dict[str, np.ndarray]) -> List[str]:
        """
        Format marker coordinate data section.
        
        Args:
            section_name: Name of the section
            marker_data: Marker coordinate data
            
        Returns:
            List of formatted lines
        """
        lines = [f"% {section_name} DATA", f"[{section_name}]"]
        
        # Get dimensions
        if marker_data:
            first_marker = next(iter(marker_data.values()))
            n_timesteps = len(first_marker)
            n_dims = first_marker.shape[1] if len(first_marker.shape) > 1 else 1
            
            lines.append(f"% Dimensions: {n_timesteps} timesteps x {n_dims}D coordinates")
            lines.append(f"% Markers: {len(marker_data)}")
            
            # Add marker names as header
            marker_names = sorted(marker_data.keys())
            header_line = "Time\t" + "\t".join([f"{name}_X\t{name}_Z" for name in marker_names])
            lines.append(header_line)
            
            # Add data rows
            for t in range(n_timesteps):
                row_data = [str(t)]
                for marker_name in marker_names:
                    coords = marker_data[marker_name][t]
                    if len(coords) >= 2:
                        row_data.extend([f"{coords[0]:.6f}", f"{coords[1]:.6f}"])
                    else:
                        row_data.extend(["NaN", "NaN"])
                
                lines.append("\t".join(row_data))
        
        lines.append("")
        return lines
    
    def _format_segment_section(self, section_name: str, segment_data: Dict[str, float]) -> List[str]:
        """
        Format segment length data section.
        
        Args:
            section_name: Name of the section
            segment_data: Segment length data
            
        Returns:
            List of formatted lines
        """
        lines = [f"% {section_name} DATA", f"[{section_name}]"]
        lines.append("% Segment_Name\tAverage_Length")
        
        for segment_name, avg_length in sorted(segment_data.items()):
            lines.append(f"{segment_name}\t{avg_length:.6f}")
        
        lines.append("")
        return lines
    
    def _format_statistics_section(self, section_name: str, stats_data: Dict[str, Dict[str, float]]) -> List[str]:
        """
        Format statistics data section.
        
        Args:
            section_name: Name of the section
            stats_data: Statistics data
            
        Returns:
            List of formatted lines
        """
        lines = [f"% {section_name} DATA", f"[{section_name}]"]
        
        if stats_data:
            # Get all unique stat keys
            all_stat_keys = set()
            for item_stats in stats_data.values():
                all_stat_keys.update(item_stats.keys())
            
            stat_keys = sorted(all_stat_keys)
            header = "Item\t" + "\t".join(stat_keys)
            lines.append(f"% {header}")
            
            for item_name, item_stats in sorted(stats_data.items()):
                row_data = [item_name]
                for stat_key in stat_keys:
                    value = item_stats.get(stat_key, np.nan)
                    row_data.append(f"{value:.6f}" if not np.isnan(value) else "NaN")
                
                lines.append("\t".join(row_data))
        
        lines.append("")
        return lines
    
    def export_to_file(self, filepath: str) -> bool:
        """
        Export all data to a MuboKap Input file.
        
        Args:
            filepath: Output file path
            
        Returns:
            True if export successful, False otherwise
        """
        try:
            output_path = Path(filepath)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(output_path, 'w', encoding='utf-8') as f:
                # Write header
                header_lines = self._format_header()
                f.write('\n'.join(header_lines) + '\n\n')
                
                # Write data sections
                for section_name, section_info in self.data_sections.items():
                    section_type = section_info['type']
                    section_data = section_info['data']
                    
                    if section_type == 'marker_coordinates':
                        lines = self._format_marker_section(section_name, section_data)
                    elif section_type == 'segment_lengths':
                        lines = self._format_segment_section(section_name, section_data)
                    elif section_type == 'statistics':
                        lines = self._format_statistics_section(section_name, section_data)
                    else:
                        lines = [f"% Unknown section type: {section_type}", ""]
                    
                    f.write('\n'.join(lines) + '\n')
                
                # Write footer
                f.write("% End of MuboKap Input File\n")
            
            return True
            
        except Exception as e:
            print(f"Error exporting to file {filepath}: {str(e)}")
            return False
    
    def clear_data(self) -> None:
        """Clear all data sections and metadata."""
        self.data_sections = {}
        self.metadata = {}
    
    def get_export_summary(self) -> Dict[str, Any]:
        """
        Get summary of data ready for export.
        
        Returns:
            Dictionary with export summary
        """
        summary = {
            'metadata_items': len(self.metadata),
            'data_sections': len(self.data_sections),
            'sections': {}
        }
        
        for section_name, section_info in self.data_sections.items():
            section_data = section_info['data']
            summary['sections'][section_name] = {
                'type': section_info['type'],
                'items': len(section_data) if isinstance(section_data, dict) else 0
            }
        
        return summary